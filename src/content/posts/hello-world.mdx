---
title: "Hello World"
date: "2024-03-08"
---

For a recent project, I had to create a dropzone component that had a dashed border. To add a bit of delight, I wanted to animate the border on hover. 

It wasn't quite as eassy as I thought it might be.

Let's start with the first problem. The design required precise control of the dash pattern, which CSS doesn't provide. 

Additionally, it required rounded edges, and animatedion on hover. Native CSS properties don't support the customization of border-style. 

One approach could bhave to use linear-gradient, similar to the appracus used here. However, this doesn;t place nicely with border radisu. but it won’t follow rounded corners cleanly. You’ll get straight edges and awkward corners, even with masks/clip tricks.

Clipping mask.Gradients + masks: possible to approximate rounded corners with multiple layered gradients/masks, but brittle, complex, and still not true dash fidelity.

Therefore, we use a trick with an SVG image inside background-image property. The SVG features give us the ability to change the distance between dashed lines, set custom pattern, add dash offset or even change a line cap. Generated SVG image is vector and it fills width and height of elements by 100%, so it doesn't matter what size elements have.

The approach taken here was to use an SVG as a background iamge. You can’t target its internal stroke-dashoffset from CSS; it’s a rasterized image from the page’s perspective.
Animating background-position/size moves the whole image, not the stroke dash offset.

Best option remains your current approach: an absolutely positioned SVG rect overlay with stroke-dasharray and animated stroke-dashoffset. It:
Works with real borderRadius.
Gives precise dash control.
Is trivial to start/stop via an active prop while keeping pointer-events: none.
Plays nicely with responsive layouts when paired with a measurement hook.

```tsx
import { Box, BoxProps } from "@/components/elements/Box";
import { cn } from "@/utils/cn.util";

export function AnimatedDashedBorder(
  props: BoxProps & {
    animationDuration?: number;
    borderRadius?: number;
    dashArray?: string;
    strokeWidth?: number;
    svgWidth?: number;
    svgHeight?: number;
    active?: boolean;
  },
) {
  const {
    borderRadius = 8,
    animationDuration = 1,
    dashArray = "4 4",
    strokeWidth = 1,
    svgWidth,
    svgHeight,
    active = false,
    children,
    className,
    ...rest
  } = props;

  const measuredWidth = svgWidth ?? 0;
  const measuredHeight = svgHeight ?? 0;
  const w = measuredWidth - strokeWidth;
  const h = measuredHeight - strokeWidth;
  
  return (
    <svg
      width={measuredWidth}
      height={measuredHeight}
      viewBox={`0 0 ${measuredWidth} ${measuredHeight}`}
      className="group pointer-events-none absolute inset-0"
      
    >
      <rect
        x={strokeWidth / 2}
        y={strokeWidth / 2}
        width={w}
        height={h}
        rx={borderRadius}
        ry={borderRadius}
        fill="none"
        stroke="currentColor"
        strokeWidth={strokeWidth}
        strokeDasharray={dashArray}
        style={{
          transition: "stroke 0.2s",
          animation: active
            ? `dashoffset-move ${animationDuration}s linear infinite`
            : undefined,
        }}
      />
      <style>
        {`
					@keyframes dashoffset-move {
						to {
							stroke-dashoffset: -8;
						}
					}
				`}
      </style>
    </svg>
  );
}
```


## How it Works (and Why It’s Built This Way)

Draw an SVG rect inset by half the stroke so the stroke remains fully visible.

The SVG stroke is centered on the shape’s path line. If your rect starts at x=0/y=0, a stroke of width s will extend s/2 outside the SVG’s bounds and get clipped.
Offsetting the rect by strokeWidth / 2 insets the path so the stroke stays fully inside the viewBox. You then reduce the rect’s width/height by strokeWidth so the outer edge aligns with the container’s edges.
This also keeps corners crisp with rx/ry and avoids subpixel blurring/clipping on the outside edge.
Apply stroke-dasharray for dash/gap; animate stroke-dashoffset for the marching effect.
Keep the overlay non-interactive (pointer-events: none) so underlying content remains clickable.
Trigger animation programmatically (via an active prop), which you control from the parent on mouse enter/leave, focus/blur, drag-state, etc. This avoids relying on :hover on the overlay.

Sizing in Responsive UIs (and SSR)
The component is “controlled” for size—on purpose. You pass svgWidth/svgHeight. In responsive contexts, you can measure the parent (client-side) with a hook like useMeasure or useElementSize and feed those numbers into the component. This split keeps the visual layer “dumb,” avoids hidden layout reads, and makes SSR behavior explicit.
Why measuring is needed: SVG needs concrete pixel dimensions to produce precise dash spacing and avoid scaling artifacts. Percent-based SVG with normalized viewBox can render, but dash fidelity typically suffers.


